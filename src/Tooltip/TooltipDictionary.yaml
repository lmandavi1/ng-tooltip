tagInputId: "**Sample tag input tooltip**"
idforexpressioninput: Here's an [**important** anchor link](#example)
jiraApprovalProject: Select the Jira project that contains the issue you want to evaluate.
jiraApprovalIssueType: Select the issue type of the issue you want to use.
jiraApprovalIssueKey: |-
    Enter the Jira issue key of the issue you want to evaluate.

    You can use an expression to reference the **Key ID** from another **Jira Create** or **Jira Update** step.

    The **Jira Create** or **Jira Update** step you want to reference must be *before* the **Jira Approval** step that references it in the Pipeline and stage. [Learn More](https://ngdocs.harness.io/article/2lhfk506r8)
ONNtooltipId: Your pipeline name
specifyYourService: Harness Services represent your microservices/apps logically. You can propagate the same Service to as many stages as you need.
stageOverviewDeploymentType: Select the platform for your deployment. When you select a platform, its specific specs and settings appear.
deploymentTypeManifests: Add the configuration files that describe the desired state of your app in terms of Kubernetes API object descriptions. All files in **Manifests** must have the .yaml file extension. [Learn More](https://ngdocs.harness.io/article/ssbq0xh0hx)
deploymentTypeArtifacts: |-
    If the image location is not specified in your Deployment manifest, you can add the image location to Harness as an Artifact. 
    Next, you reference the Artifact you added to Harness in your manifest like this:
    `image: <+artifact.image>` 
    [Learn More](https://ngdocs.harness.io/article/4ifq51cp0i)
ciEditStage_name: Enter a name for the stage. [Learn more](https://ngdocs.harness.io/article/2chyf1acil)
ciEditStage_repoName: Enter the name of the Git repo containing your codebase. [Learn more](https://ngdocs.harness.io/article/8l31vtr4hi)
ciBuildStage_name: Enter a name for the stage. [Learn More](https://ngdocs.harness.io/article/2chyf1acil-add-a-stage)
dependencyBase_name: Enter a name for this Service Dependency step. [Learn More](https://ngdocs.harness.io/article/vo4sjbd09g-configure-service-dependency-step-settings)
ciRunStep_name: The Run step executes one or more commands on a container image. Enter a name for this Run step. [Learn More](https://ngdocs.harness.io/article/1i1ttvftm4-run-step-settings)
pluginStep_name: |-
    Enter a unique name for this Plugin step. 

    Plugins are Docker containers that perform predefined tasks. Plugins are configured as steps in your stage. Plugins can be used to deploy code, publish artifacts, send notifications, and more. [Learn More](https://ngdocs.harness.io/article/8r5c3yvb8k)
restoreCacheS3_name: |-
    Enter a name for this step.

    The [Save Cache to S3](https://ngdocs.harness.io/article/qtvjvrp9sn) step preserves files and directories between builds.

    You can restore cache using the [Restore Cache from S3](https://ngdocs.harness.io/article/zlpx6lli6d) step.
restoreCacheGcs_name: |-
    Enter a name for this step.

    The [Restore Cache from GCS](https://ngdocs.harness.io/article/e2o4sektz1) step restores files and directories that were saved using the [Save Cache to GCS](https://ngdocs.harness.io/article/11nzeuntrz) step.
savedS3Cache_name: |-
    Enter a name for this step.

    The [Save Cache to S3](https://ngdocs.harness.io/article/qtvjvrp9sn) step preserves files and directories between builds.

    You can restore cache using the [Restore Cache from S3](https://ngdocs.harness.io/article/zlpx6lli6d) step.
savedCacheGcs_name: |-
    Enter a name for this step.

    The [Restore Cache from GCS](https://ngdocs.harness.io/article/e2o4sektz1) step restores files and directories that were saved using the [Save Cache to GCS](https://ngdocs.harness.io/article/11nzeuntrz) step.
dockerHubStep_name: |-
    Enter a name for this step.

    The [Build and Push an Image to Docker Registry](https://ngdocs.harness.io/article/q6fr5bj63w) step creates a Docker image from a Dockerfile and pushes it to a Docker registry.
ciGcrStep_name: |-
    Enter a name for this step.

    The [Build and Push to GCR](https://ngdocs.harness.io/article/66ykcm0sf0) step creates a Docker image from a Dockerfile and pushes it to a GCR Docker repository.
ciEcrStep_name: |-
    Enter a name for this step.

    The [Build and Push to ECR](https://ngdocs.harness.io/article/aiqbxaef15) step creates a Docker image from a Dockerfile and pushes it to an ECR Docker repository.
jfrogArt_name: |-
    Enter a name for this step.

    The [Upload Artifacts to JFrog Artifactory](https://ngdocs.harness.io/article/gjoggc66fy) step creates a Docker image from a Dockerfile and pushes it to a JFrog Artifactory Docker repository.
conditionalExecution: |-
    Conditional Execution uses JEXL operators and expressions. [Learn More](https://commons.apache.org/proper/commons-jexl/reference/syntax.html)

     
    Examples:

     
    `<+steps.mystep.output.status> == “success”`
    `<+environment.name> != “QA”`
projectsForm_name: Enter a name for the project. [Learn more](https://ngdocs.harness.io/article/36fw2u92i4-create-an-organization)
projectsForm_color: Select a color for the project. [Learn more](https://ngdocs.harness.io/article/36fw2u92i4-create-an-organization)
projectsForm_orgIdentifier: Select an org for your project. [Learn more](https://ngdocs.harness.io/article/36fw2u92i4-create-an-organization)
passwordStrengthForm_minNumberOfCharacters: Enter a minimum length for the passwords. [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
passwordExpirationForm_daysBeforePasswordExpire: After how many days the password must expire? [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
passwordExpirationForm_daysBeforeUserNotified: How many days before password expiration should the user be notified?  [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
lockoutPolicyForm_numberOfFailedAttemptsBeforeLockout: After how many failed logins user is locked out?  [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
lockoutPolicyForm_lockOutPeriod: Enter the period for which user would be locked out.  [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
samlProviderForm_displayName: Enter a name for the SAML Provider. [Learn more](https://ngdocs.harness.io/article/mlpksc7s6c-single-sign-on-saml)
samlProviderForm_groupMembershipAttr: Enter the Group Attribute Name from your SAML Provider. [Learn more](https://ngdocs.harness.io/article/mlpksc7s6c-single-sign-on-saml)
connectorDetailsStepForm_name: Enter a name for the Connector. This is the name you will use to select this Connector in stage and step settings.
awsKmsConfigForm_credType: Select a credential type for authentication. [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_accessKey: Enter your AWS Access Key ID. [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_secretKey: Enter the Secret Key for your AWS Access Key ID. [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_awsArn: Enter the Amazon Resource Name (ARN).  [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_region: Select the AWS Region for the Secrets Manager.  [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager#region)
awsKmsConfigForm_default: Make this your default secrets manager.  [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager#region)
azureKeyVaultForm_clientId: Enter the Application (client) ID of your Azure app.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_tenantId: Enter the Directory (tenant) ID of the Azure App Directory.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_subscription: Enter your Azure Subscription ID.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_secretKey: Enter azure authentication key.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_vaultName: Select the Vault you want to use. [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_default: Make this your default secrets manager. [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
vaultConfigForm_vaultUrl: Enter the Vault URL. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_basePath: Enter the Base Secret Path. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_accessType: Select the Authentication Type.  [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_authToken: Enter Periodic Token.  [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_appRoleId: Enter the App Role ID.  [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_secretId: Enter the Secret ID. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_engineType: Select Secret Engine Type. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_secretEngineName: Enter the name of the Secret Engine. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_secretEngineVersion: Enter the engine version. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_renewalInterv: Enter how often Harness Delegate should reload the Vault access token. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_readOnly: Select to make secrets within this vault Read-Only. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_default: Make this your default secrets manager.
stepGithubAuthForm_enableAPIAccess: Select this option if you are using this GitHub Connector for a Harness [Trigger](https://ngdocs.harness.io/article/hndnde8usz-triggering-pipelines), [Harness Git Experience](https://ngdocs.harness.io/article/utikdyxgfz-harness-git-experience-overview), or authenticating using a [GitHub App](https://ngdocs.harness.io/article/nze5evmqu1-git-hub-app-support).
deployService_name: "Enter a name for this Service. You can propagate this Service in subsequent stages by selecting its name in that stage's Service settings. "
specifyYourEnvironment: |-
    Select or create a new Environment. You can select this Environment in subsequent stages.

    Environments represent your deployment targets logically (QA, Prod, etc). You can add the same Environment to as many stages are you need. Infrastructure Definitions represent your target infrastructure physically. They are the actual clusters, hosts, etc.

    By separating Environments and Infrastructure Definitions, you can use the same Environment in multiple stages while changing the target infrastructure settings with each stage.
k8InfraConnector: |-
    Select or create the Connector that connects Harness to your target cluster. [Learn More](https://ngdocs.harness.io/article/0ud2ut4vt2)

    Here's a [video](https://youtu.be/wUC23lmqfnY) that walks through setting up a Kubernetes Cluster Connector.
k8InfraNamespace: |-
    Enter the target namespace in target cluster. 

    The namespace must already exist during deployment. Harness will not create a new namespace if you enter one here. If you leave this setting empty, the `default` namespace is used. [Learn More](https://ngdocs.harness.io/article/0ud2ut4vt2)
k8InfraReleaseName: |-
    During deployment Harness creates a ConfigMap listing the resources of the release and uses the **Release name** for tracking them. 

    The **Release name** is a combination of `release-` and a unique string created using the Harness expression `<+INFRA_KEY>`. 

    For example, in a Kubernetes deployment you can see `harness.io/release-name=release-2f9eadcc06e2c2225265ab3cbb1160bc5eacfd4f`.

    The release name must be unique across the cluster. `release-<+INFRA_KEY>` ensures a unique name.

    `release-` is used as a prefix because Kubernetes service and pod names must follow RFC-1035 and must consist of lowercase alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
manifestDetails_identifier: Enter a name that identifies this manifest. [Learn More](https://ngdocs.harness.io/article/ssbq0xh0hx)
manifestDetails_gitFetchType: Select a branch or commit ID for the manifest.
manifestDetails_commitId: Enter the commit ID in the repo where the manifest is located.
manifestDetails_branch: Enter the branch in the repo where the manifest is located, such as `main`.
imagePath_imagePath: |+
    Enter the name of the artifact you want to deploy, such as `library/nginx`. [Learn More](https://ngdocs.harness.io/article/4ifq51cp0i)

    Official images in public repos often need the label `library`, e.g. `library/tomcat`.

    Wildcards are not supported.

imagePath_tag: Enter the Docker [image tag](https://docs.docker.com/engine/reference/commandline/tag/).
setContainerResources: |
    Resources limits allow setting maximum values for the resources the container is allowed to use at runtime.
    Use “Limit Memory” to limit the memory that the container can use. Limits for memory are measured in bytes. You can express memory as a plain integer or as a fixed-point number using one of these suffixes: G, M. You can also use the power-of-two equivalents: Gi, Mi.
    Use “Limit CPU” to limit the number of cores that the container can use. Limits for CPU resources are measured in cpu units. Fractional requests are allowed. The expression 0.1 is equivalent to the expression 100m, which can be read as "one hundred millicpu"
timeout: |
    You can use:
    w for weeks
    d for days
    h for hours
    m for minutes
    s for seconds
    ms for milliseconds
image: The name and tag of a Docker image to use in this stage. For example, a database container or a container to run integration tests on. Include the image name and tag. Harness will default to the latest tag if unspecified. You can use any Docker image from any public or private Docker registry.
privileged: Enable this option to run the container with escalated privileges. This is the equivalent of running a container with the Docker --privileged flag.
tags: Specify one or more tags for the Docker image
optimize: Enables redo snapshot mode
dockerfile: If not provided assumed to be in the root folder of the codebase
context: Context represents a directory containing a Dockerfile which kaniko will use to build your image. For example, a COPY command in your Dockerfile should refer to a file in the build context.
labels: Use Labels to add metadata to the Docker image
buildArgs: Build-time variables
target: Build the specified stage as defined inside the Dockerfile
region: AWS Region
imageName: The name of the image that will be pushed to the target container registry.
gcsBucket: GCS Bucket
sourcePath: Use regex to upload multiple files
gcsS3Target: The path to store the cache in, relatively to the bucket. If not provided the cache will be save to [bucket]/
connector: Container Registry to use to download the image use to run commands on
restoreCacheKey: The key that can be used to restore this cache. You can use the checksum macro to create a key that is based on a file’s checksum. For example, myApp-{ { checksum filePath1 } }
archiveFormat: Select archive format. Default is Tar
failIfKeyNotFound: Fail step if the key doesn’t exist. Default is False.
s3Bucket: S3 Bucket
endpoint: Endpoint for S3 compatible providers (not needed for AWS).
pathStyle: Select whether to use Virtual Hosted Style (http://bucket.host/key) or Path Style (http://host/bucket/key). For MinIO use Path Style (true). Default value is false.
reportPaths: Enter paths to file(s) that store results in the JUnit XML format. Regex is supported.
environmentVariables: Environment variables injected into the container to be used in the commands.
outputVariables: Output Variables can be used to expose Environment Variables to be used by other steps/stages of the pipeline
saveCacheKey: The key the cache will be identified by. You can use the checksum macro to create a key that is based on a file’s checksum. For example, myApp-{ { checksum filePath1 } }
saveCacheSourcePaths: A list of files/folders to cache
saveCacheOverride: Select whether you want to override the cache if the key already exists. default is true
namespace: Namespace must exist
cloneCodebase: Unless disabled, Harness automatically clones your codebase repository before executing the steps of this stage
dependencyConnector: Container registry to pull the service dependency image from
dependencyEnvironmentVariables: Environment variables injected into the container
dependencyEntryPoint: Overrides the image ENTRYPOINT. Commands should be in exec form. Each command and parameter should be added separately. [Learn More](https://ngdocs.harness.io/article/vo4sjbd09g-configure-service-dependency-step-settings)
dependencyArgs: Overrides the image COMMAND
dockerHubConnector: Docker Connector to use for uploading the image
dockerHubRepository: Docker repository. For example, "plugins/s3"
dockerHubRemoteCache: The remote cache repository needs to be created in the same account and organization as the build image. The repository must already exist for caching to work
ecrConnector: AWS connector to use for uploading the image to ECR
ecrAccount: AWS Account ID
ecrRemoteCache: The remote cache repository needs to be created in the same account and region as the build image. The repository must already exist for caching to work
gcrConnector: GCP connector to use for uploading the image to GCR
gcrHost: GCR Host
gcrProjectID: GCR Project ID
gcrRemoteCache: The remote cache repository needs to be created in the same host and project as the build image. The repository will be automatically created if it doesn’t exist.
gcsConnector: GCP connector to use for uploading the artifact(s) to GCS
jFrogArtifactoryTarget: Repository name relative to the server URL in the connector. If pom.xml is not present then target should be full path to artifacts folder (groupID/artifactID/version)
pluginImage: The name of the Plugin Docker image. The image name should include the tag and will default to the latest tag if unspecified. You can use any docker image from any docker registry, including docker images from private registries
pluginSettings: Plugin specific settings. Please refer to the plugin's documentation page
restoreCacheGcpConnector: GCP connector to use for restoring the cache from GCS
restoreCacheAwsConnector: AWS connector to use for restoring the cache from S3
runCommand: POSIX shell script executed inside the container. The script is invoked as if it were the container’s entrypoint.
runTestsArgs: The arguments to be passed to the buildTool. For maven, it will be a goal
runTestsBuildTool: Build automation tool
runTestsLanguage: The programming language of the source code to build
runTestsPackages: List of source code package prefixes separated by comma. E.g. com.company., io.company., migrations.
runTestsTestAnnotations: "List of test annotations used in unit testing. They should be separated by comma. Any method annotated with this will be treated as test method. The defaults are: org.junit.Test, org.junit.jupiter.api.Test, org.testng.annotations.Test"
runTestsPreCommand: Commands used for setting up the environment before running the tests
runTestsPostCommand: Commands used for cleaning up the environment after running the tests
s3Connector: AWS connector to use for uploading the artifact(s) to S3
gcpConnector: GCP connector to use for saving the cache to GCS
saveCacheS3Connector: AWS connector to use for saving the cache to S3
stageSpecificationsSharedPaths: By default, all of a stage’s steps use the same workspace to share data. If you need to share additional paths between steps, add Shared Paths.
connectorDetailsStepFormGithub_name: Enter a name for this Connector. You will use this name to select the Connector.
gitDetailsStepForm_url: |-
    Enter the URL for your repo or account:

    - **Repos:** copy the URL provided by the Git provider. For example, see GitHub's [**Code** setting](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository-from-github/cloning-a-repository).
    - **Accounts:** The URL of your Git provider account, such as `https://github.com/mycompany`. In **Test Repository**, enter a repo to test the connection. 

    [Learn More](https://ngdocs.harness.io/category/xyexvcc206)
gitDetailsStepForm_validationRepo: |-
    Enter a repo name to test the credentials. The Connector will connect to the repo to test account credentials. The repo is not linked to the Connector.

    The Connector will still be created at the Account level.
connectorDetailsStepFormAws_name: Enter a name for this AWS Connector. You will use the name to select this Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/m5vkql35ca)
stepAwsAuthForm_crossAccountAccess: |-
    Select this option if you want to use one AWS account for the connection, but you want to deploy or build in a different AWS account. 

    In this scenario, the AWS account used for AWS access in **Credentials** will assume the IAM role you specify in **Cross-account role ARN** setting.

    This option uses the [AWS Security Token Service (STS)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html) feature.

    [Learn More](https://ngdocs.harness.io/article/m5vkql35ca)
stepAwsAuthForm_crossAccountRoleArn: |-
    The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.

    The assumed role must have all the IAM policies required to perform your Harness operations, such as Amazon S3, ECS (Existing Cluster), and AWS EC2 policies. For more information, see [Assuming an IAM Role in the AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html) from AWS.
stepAwsAuthForm_externalId: |-
    If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.

    For more information, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html) from AWS.
connectorDetailsStepFormGcp_name: Enter a name for this GCP Connector. [Learn More](https://ngdocs.harness.io/article/yykfduond6)
connectorDetailsStepFormK8sCluster_name: |-
    Enter a name for this Kubernetes Cluster Connector. 

    The Kubernetes Cluster Connector is platform-agnostic. Use it to access a cluster on any platform. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_masterUrl: |-
    The Kubernetes master node URL. The easiest method to obtain the master URL is using kubectl:

    ```
    kubectl cluster-info
    ```
    [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
connectorDetailsStepFormArtifactory_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/euueiiai4m)
stepArtifactoryAuthForm_artifactoryServerUrl: |-
    Enter in your base URL followed by your module name.

    For most artifacts, use `https://mycompany.jfrog.io/module_name/`.

    For example: `https://harness.jfrog.io/artifactory/`

    In some cases, you can use `https://server_name/artifactory/module_name`.

    The URL really depends on how you have set up Artifactory, and whether it is local, virtual, remote, or behind a proxy.

    To ensure you use the correct URL, copy it from your Artifactory settings.

    [Learn More](https://ngdocs.harness.io/article/euueiiai4m)

    **Note:** using `artifactory/` at the end of the URL often solves path issues.
connectorDetailsStepFormDockerRegistry_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/u9bsd77g5a)
dockerAuthForm_dockerRegistryUrl: |-
    Enter the URL of the Docker Registry. The Docker Registry URL for Docker Hub is `https://registry.hub.docker.com/v2/` or `https://index.docker.io/v2/`.

    [Learn More](https://ngdocs.harness.io/article/u9bsd77g5a)
helmRepoAuthForm_helmRepoUrl: |-
    The URL of the chart repo. [Learn More](https://ngdocs.harness.io/article/a0jotsvsi7)

    For example: `https://charts.bitnami.com/bitnami`
connectorDetailsStepFormHttpHelmRepo_name: |+
    Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/a0jotsvsi7)

    For Helm charts stored in repos such as Amazon S3 or GCS (Google Cloud Storage), you will need to create a cloud platform Connector for that repo. For more information, see [Cloud Platform Connectors](https://ngdocs.harness.io/category/1ehb4tcksy).

connectorDetailsStepFormNexus_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/faor0dc98d)
nexusAuth_nexusServerUrl: The URL that you use to connect to your Nexus server. For example, `https://nexus2.dev.mycompany.io`. [Learn More](https://ngdocs.harness.io/article/faor0dc98d)
nexusAuth_nexusVersion: |-
    Harness lists the supported Nexus versions, 2.x and 3.x:

    - For Nexus 2.x, Harness supports repository formats Maven, npm, and NuGet. See Sonatype's website at [Supported Formats](https://help.sonatype.com/repomanager3/supported-formats).
    - For Nexus 3.x, Harness supports repository formats Docker 3.0 and greater, Maven, npm, NuGet.
connectorDetailsStepFormCodecommit_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/jed9he2i45)
awsCCDetailsForm_urlType: |-
    You can select **Region** or **Repository**.

    You can add a connection to your entire region or just a repo in the account. Selecting a region enables you to use one Connector for all of your subordinate repositories.

    You must enter a repo URL even if you select region. Harness will use the repo URL Later to test this connection.

    [Learn More](https://ngdocs.harness.io/article/jed9he2i45)
awsCCDetailsForm_url: |-
    Enter the path of the AWS CodeCommit repository to use.

    For example: `https://git-codecommit.us-east-2.amazonaws.com/v1/repos/MyDemoRepo`
connectorDetailsStepFormBitbucket_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/iz5tucdwyu)
connectorDetailsStepFormJira_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/ud8rysntnz)
k8InfraAllowSimultaneousDeployments: By default, Harness queues deployments to the same infrastructure to avoid conflicts. If you want to allow simultaneous deployments to this infrastructure, enable this option.
infraProvisionerBase_provisionerEnabled: Select this option to use an infrastructure provisioner to dynamically provision the target infrastructure for the deployment. [Learn More](https://ngdocs.harness.io/article/boug6e884h)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_name: Enter a name for this step.
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.command: Identify if the plan created by this step will be used with a Terraform Apply or Terraform Destroy step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.provisionerIdentifier: |-
    Enter a unique value in **Provisioner Identifier**.

    The Provisioner Identifier identifies the provisioning done in this step. You use the Provisioner Identifier in additional steps to refer to the provisioning done in this step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    The most common use of Provisioner Identifier is between the Terraform Plan and Terraform Apply steps. To have the Terraform Apply step apply the provisioning from this Terraform Plan step, you use the same Provisioner Identifier in both steps.
terraformEdit-TerraformApply-INFRASTRUCTURE_name: Enter a name for this step.
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.configuration.type: |-
    When provisioning target infrastructure, select **Inherit From Plan**. If you select **Inline**, then you aren't using the previous Terraform Plan step. You are entering separate Terraform files and settings.
    [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.provisionerIdentifier: When provisioning target infrastructure, enter the same Provisioner Identifier you entered in the Terraform Plan step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_name: Enter a name for this step.
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.configuration.type: |-
    When provisioning target infrastructure, select **Inherit from Apply**.

    The Terraform Delete step will delete the infrastructure provisioned by the Terraform Apply step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.provisionerIdentifier: |-
    The Provisioner Identifier uniquely identifies the provisioning done by specific Terraform steps.

    When provisioning target infrastructure, enter the same Provisioner Identifier used but the Terraform Apply step.

    The Terraform Delete step will delete the infrastructure provisioned by the Terraform Apply step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
jiraCreate_name: Enter a name for this step.
jiraCreate_spec.projectKey: Select the Jira project where you want to create a ticket. [Learn More](https://ngdocs.harness.io/article/yu40zr6cvm)
jiraCreate_spec.issueType: Select a Jira issue type from the list of types in the Jira project you selected. [Learn More](https://ngdocs.harness.io/article/yu40zr6cvm)
jiraCreate_spec.summary: Add a summary for the new Jira ticket.
harnessApproval_name: Enter a name for this step.
harnessApproval_spec.includePipelineExecutionHistory: Enable this option to provide approvers with the execution history for this Pipeline. This can help approvers make their decision. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.approvers.userGroups: Select the Harness User Groups that will approve the step. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.approvers.minimumCount: Enter how many of the Users in the User Groups must approve the step. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.approvers.disallowPipelineExecutor: Enable this option if you don't want to allow the User that initiated the Pipeline execution to approve this step. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
terraformRollback_name: |
    Enter a name for this step. 
terraformRollback_spec.provisionerIdentifier: |-
    Enter the same Provisioner Identifier you used in the Terraform Plan and/or Apply steps that provisioned the infrastructure you want to roll back. Harness will roll back the exact infrastructure provisioned in those steps.
    [Learn More](https://ngdocs.harness.io/article/jgi6d73noy)
shellScriptForm_name: Enter a name for this step.
shellScriptForm_spec.shell: "Select the shell type of you script. "
k8BgSwap_name: Enter a name for this step.
k8BG_name: Enter a name for this step.
k8Apply_name: Enter a name for this step.
k8DeleteData_name: Enter a name for this step.
k8DeleteData_spec.deleteResources.type: |-
    Select the resource(s) you want removed:

    - **Resource Name:** Use a resource name in the format `[namespace]/Kind/Name`, with `namespace` being optional. For example, `Deployment/harness-example-deployment-canary`.
    - **Manifest Path:** Enter the path to the manifest for the resource you want to delete. The path is relative to the folder path entered in **File/Folder Path** in the **Manifest Details** settings.
    - **Release Name:** Deletes all of the resources for a release. If you select the **Delete namespace** option, Harness will delete the namespace(s) defined in the release.

    [Learn More](https://ngdocs.harness.io/article/eaj0xuegln)
k*CanaryDelete_name: Enter a name for this step.
k8RolloutDeploy_name: Enter a name for this step.
k8CanaryDeploy_name: Enter a name for this step.
k8Scale_name: Enter a name for this step.
k8Scale_spec.workload: |-
    Enter the name of the resource to scale in the format `[namespace/]Kind/Name`, with `namespace` optional. For example: 

    ```
    default/Deployment/harness-example
    ```

    You can scale a Deployment, DaemonSet, or StatefulSet.

    You can only enter one resource in **Workload**. To scale another resource, add another **K8s Scale** step. 

    [Learn More](https://ngdocs.harness.io/article/jxe5z9domw)
k8RollingRB_name: Enter a name for this step.
terraformEdit-TerraformDestroy-EXECUTION_name: Enter a name for this step.
terraformEdit-TerraformDestroy-EXECUTION_spec.configuration.type: |-
    There are three options:

    - **Inline:** Removes the provisioned resources you identify using **Provisioner Identifier** and other settings. 

    - **Inherit from Plan:** Removes the resources defined in the Harness **Terraform Plan** step that you identify using **Provisioner Identifier**. Similar to `terraform plan -destroy`.

    - **Inherit from Apply:** Removes the resources defined in the Harness **Terraform Apply** step that you identify using **Provisioner Identifier**. Similar to `terraform destroy`.

    [Learn More](https://ngdocs.harness.io/article/j75xc704c8)
terraformEdit-TerraformDestroy-EXECUTION_spec.provisionerIdentifier: Enter the same **Provisioner Identifier** you used in the **Terraform Plan** or **Terraform Apply** step that planned/provisioned the resources you want to destroy. [Learn More](https://ngdocs.harness.io/article/j75xc704c8)
terraformEdit-TerraformApply-EXECUTION_name: Enter a name for this step.
terraformEdit-TerraformApply-EXECUTION_spec.configuration.type: |-
    Select **Inline** or **Inherit from Plan**.

    - If you select **Inherit from Plan**, you'll enter the unique Id used by a **Terraform Plan** step in **Provisioner Identifier**.

    - If you select **Inline**, you'll configure this **Terraform Apply** step to use a Terraform script without any **Terraform Plan** step.

    [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
terraformEdit-TerraformApply-EXECUTION_spec.provisionerIdentifier: |-
    The **Provisioner Identifier** identifies the provisioning applied in this step. 

    - If you selected **Inherit from Plan** in **Configuration Type**, enter the Id used by the **Terraform Plan** step for the plan you want to apply.

    - If you selected **Inline** in **Configuration Type**, create a new Id.

    [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
terraformPlanEditView-tfPlan-EXECUTION_name: Enter a name for this step.
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.command: |-
    Select how you want this plan used later in the stage:

    - **Apply:** The plan will be applied by a **Terraform Apply** step later in your stage.
    - **Destroy:** The plan will be applied by a **Terraform Destroy** step later in your stage.

    [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
terraformPlanEditView-tfPlan-EXECUTION_spec.provisionerIdentifier: |-
    Enter a unique string to identify the provisioning configured in this step. 

    You will use this **Provisioner Identifier** in additional steps to refer to the provisioning set up in this step.

    The most common use of **Provisioner Identifier** is between the **Terraform Plan** and **Terraform Apply** steps. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
barrierStep_name: Enter a name for this step.
barrierStep_spec.barrierRef: |-
    Select a Barrier name for the new barrier. [Learn More](https://ngdocs.harness.io/article/dmlf8w2aeh)

    Barriers are added in the Pipeline's **Flow Control** settings. If you do not see any names in **Barrier Reference**, then no barriers have been added to **Flow Control**.

    You can have multiple barriers in a stage. Every barrier in the same stage must use a unique Barrier Reference.
pipelineCreate_name: |-
    Enter a name for the Pipeline. You can also edit the automatically generated Id. 

    The Pipeline name can be edited later, but Ids cannot be edited once a Pipeline has been saved.

    If you are new to Harness, try a [Quickstart](https://ngdocs.harness.io/article/u8lgzsi7b3).
pipelineCreate_timeout: |-
    Enter a timeout for the entire Pipeline. You can also make this setting a runtime input or use a Harness expression. 

    Keep in mind that all Pipeline steps have timeout settings too.

    Also, Approval steps and stages might pause execution but they do not stop the Pipeline Timeout counter.

    You can change this setting at any time.
ShellScript_stepName: |-
    The Shell Script step can execute scripts in the shell session of the stage in the following ways:

    - Execute scripts on the host running a Harness Delegate. You can use **Delegate Selector** in **Advanced** to identify which Harness Delegate to use.
    - Execute scripts on a remote target host.

    See **Execution Target** in **Optional Configuration** to select where the script is run. [Learn More](https://ngdocs.harness.io/article/k5lu0u6i1i)
shellScriptForm_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
shellScriptForm_spec.source.spec.script: |-
    Enter your script. For example, here is a script that exports the variable names `BUILD_NO` and `LANG`:

    ```
    export BUILD_NO="345"
    export LANG="en-us" 
    ```

    You must use quotes around the value because environment variables are Strings.

    You can use Harness [variable expressions](https://ngdocs.harness.io/article/lml71vhsim-harness-variables) in your script and its comments. Harness will attempt to evaluate and render the variable expressions at runtime. Do not use variable expressions that Harness cannot evaluate at this step in the Execution.
    [Learn More](https://ngdocs.harness.io/article/k5lu0u6i1i)
Http_stepName: The HTTP step can run HTTP methods containing URLs, methods, headers, and variables. You can add assertions that use the response from the HTTP method.
httpWidget_name: Enter a name for this step.
httpWidget_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
httpWidget_spec.url: Enter the URL for the HTTP call.
httpWidget_spec.method: Select the [HTTP method](https://restfulapi.net/http-methods/).
httpWidget_spec.requestBody: Enter the message body (if any) of the HTTP message.
httpWidget_spec.assertion: The assertion is used to validate the incoming response.
httpWidget_spec.headers: |-
    Enter headers for the message, such as the media type for the message. 

    For example, if you are using the GET method, the headers are used to specify the GET response body message type Harness will check for.

    You can enter multiple header entries. You can use Harness secrets for token headers, also.
httpWidget_spec.outputVariables: Add output variables to be used in other steps in your stage.
JiraApproval_stepName: |-
    You can use Jira issues to approve or reject a Pipeline or stage at any point in its execution.

    During deployment, the Jira issue you select is evaluated according to **Approval Criteria** you define in this step. 

    If the issue meets the criteria the Pipeline or stage may proceed. [Learn More](https://ngdocs.harness.io/article/2lhfk506r8)
jiraApproval_name: Enter a name for this step.
jiraApproval_timeout: |-
    Enter a timeout for this step. Jira communication can take a few minutes. Do not use a brief timeout.

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
jiraApproval_spec.connectorRef: Create or select the Jira Connector to use. [Learn More](https://ngdocs.harness.io/article/e6s32ec7i7)
jiraApprovalapprovalCriteria: |-
    The **Approval Criteria** determines if the Pipeline or stage is approved or rejected. [Learn More](https://ngdocs.harness.io/article/2lhfk506r8)

    You can specify criteria using **Conditions** and/or **JEXL Expression**. If you use them in combination they both must evaluate to `True` for criteria to work.

    Whether the Pipeline/stage stops executing depends on the stage or step [Failure Strategy](https://ngdocs.harness.io/article/0zvnn5s1ph-define-a-failure-strategy-on-stages-and-steps).

    In **Optional Configuration**, in **Rejection Criteria**, you can define criteria for rejecting the approval.

    If you add rejection criteria it is used in addition to the settings in **Approval Criteria**.
K8sBGSwapServices_stepName: In this step, Harness swaps the primary service (prod traffic) to the pod set running the new app and the stage service (stage traffic) to the set running the old app. [Learn More](https://ngdocs.harness.io/article/mog5tnk5pi)
k8BgSwap_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
K8sBlueGreenDeploy_stepName: |-
    This step deploys your new app version to the stage pod set. 

    The first time this step is run it creates any needed Kubernetes services and pod sets for the app.

    The **Swap** step follows this step. It swaps the primary service to the new app version's pod set, and the stage service to old app version's stage pod set.

    [Learn More](https://ngdocs.harness.io/article/mog5tnk5pi)
k8BG_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
k8BG_spec.skipDryRun: |-
    By default, Harness uses the `--dry-run` flag on the `kubectl apply` command, which prints the object that would be sent to the cluster without really sending it. 

    If the **Skip Dry Run** option is selected, Harness will not use the `--dry-run` flag.
k8Apply_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
K8sApply_stepName: |-
    The **K8s Apply** step allows you to deploy any resource you have set up in the **Manifests** section in **Service**.

    By default, the Harness Kubernetes Rolling, Canary, and Blue Green steps will deploy all of the resources you have set up in the **Manifests** section.

    In some cases, you might have resources in **Manifests** that you do not want to deploy as part of the main deployment, but want to apply as another step in the stage.

    In these cases, you use the **K8s Apply** step to deploy those resources. [Learn More](https://ngdocs.harness.io/article/00el61pzok)
k8Apply_spec.filePaths: |-
    Enter the path to a manifest file. **File Path** has the following requirements:

    - The path to the manifest for the **Apply** step must be subordinate to the path for the manifest in the **Manifests** section of the **Service Definition**. The manifest cannot be in the same folder as **Manifests**.
    - The path must include the folder name and the file name.

    [Learn More](https://ngdocs.harness.io/article/00el61pzok)
k8Apply_spec.skipDryRun: |-
    By default, Harness uses the `--dry-run` flag on the `kubectl apply` command, which prints the object that would be sent to the cluster without really sending it. 

    If the **Skip Dry Run** option is selected, Harness will not use the `--dry-run` flag.
k8Apply_spec.skipSteadyStateCheck: |-
    By default, Harness checks to see if a deployed workload has reached steady state.

    If you select this option, Harness will not check that the workload has reached steady state.
K8sDelete_stepName: The K8s Delete step can remove any deployed Kubernetes resources. [Learn More](https://ngdocs.harness.io/article/eaj0xuegln)
k8DeleteData_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
k8DeleteData_spec.deleteResources.spec.deleteNamespace: If you select the **Delete namespace** option, Harness will delete the namespace(s) defined in the release.
K8sCanaryDelete_stepName: The **Canary Delete** step is used to clean up the workload deployed by the [Canary](https://ngdocs.harness.io/article/17wrdeuv0x-) step. [Learn More](https://ngdocs.harness.io/article/922mtcvank)
k*CanaryDelete_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
K8sRollingDeploy_stepName: |-
    The **K8s Rollout Deploy** step performs a Kubernetes [rolling update strategy](https://ngdocs.harness.io/article/0zsf97lo3c-deployment-concepts). 

    All nodes within a single environment are incrementally added one-by-one with a new service/artifact version. The rolling update uses the number of pods you specified in **Manifests** (number of replicas). [Learn More](https://ngdocs.harness.io/article/2bwlugh9gi)
k8RolloutDeploy_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
k8RolloutDeploy_spec.skipDryRun: |-
    By default, Harness uses the `--dry-run` flag on the `kubectl apply` command, which prints the object that would be sent to the cluster without really sending it. 

    If the **Skip Dry Run** option is selected, Harness will not use the `--dry-run` flag.
K8sCanaryDeploy_stepName: The **K8s Canary Deploy** step sets how many pods are created for a Canary deployment of the files in your Service Definition **Manifests** section. [Learn More](https://ngdocs.harness.io/article/i5p4feil89)
k8CanaryDeploy_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
k8CanaryDeploy_spec.instanceSelection: |-
    Define how many pods are deployed for a Canary test of the configuration files in your Service Definition **Manifests** section:
     
    - If you selected **Instance Count**, this is simply the number of pods.
    - If you selected **Percentage**, enter a percentage of the pods defined in your Service Definition **Manifests** files.

    [Learn More](https://ngdocs.harness.io/article/i5p4feil89)
k8CanaryDeploy_spec.skipDryRun: |-
    By default, Harness uses the `--dry-run` flag on the `kubectl apply` command, which prints the object that would be sent to the cluster without really sending it. 

    If the **Skip Dry Run** option is selected, Harness will not use the `--dry-run` flag.
K8sScale_stepName: The **K8s Scale** step you can scale the number of running pods up or down by count or percentage. [Learn More](https://ngdocs.harness.io/article/jxe5z9domw)
k8Scale_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
k8Scale_spec.instanceSelection: |-
    Define how many pods you want:

    - If you selected **Instance Count**, this is simply the number of pods.
    - If you selected **Percentage**, enter a percentage of the pods defined in your Service Definition **Manifests** files.

    [Learn More](https://ngdocs.harness.io/article/jxe5z9domw)
k8Scale_spec.skipSteadyStateCheck: |-
    By default, Harness checks to see if a deployed workload has reached steady state.

    If you select this option, Harness will not check that the workload has reached steady state.
K8sRollingRollback_stepName: |-
    The **K8s Rollout Rollback** step will roll back the workloads deployed by the Rolling Deployment step. [Learn More](https://ngdocs.harness.io/article/xsla71qg8t)

    **Rollback rolls back workloads only.** If there are other objects or operations executed in your stage, Harness does not roll those back.
k8RollingRB_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
TerraformDestroy_stepName: |-
    The **Terraform Destroy** step removes any provisioned infrastructure, just like running the `terraform destroy` command. [Learn More](https://ngdocs.harness.io/article/j75xc704c8)

    The **Terraform Destroy** step is independent of any other Terraform provisioning steps. It's not restricted to removing the infrastructure deployed in its stage. It can remove any infrastructure you've provisioned *using Harness*.

    The **Terraform Destroy** step can also be used as part of target infrastructure provisioning. [Learn More](https://ngdocs.harness.io/article/uznls2lvod-provision-infra-dynamically-with-terraform)
terraformEdit-TerraformDestroy-EXECUTION_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
TerraformRollback_stepName: Use the Terraform Rollback step to roll back your infrastructure and resources and return your environment to its pre-deployment state. [Learn More](https://ngdocs.harness.io/article/jgi6d73noy)
terraformRollback_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
terraformEdit-TerraformApply-EXECUTION_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
TerraformApply_stepName: |-
    You can apply a Terraform plan or script using the **Terraform Apply** step. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)

    Typically the **Terraform Apply** step is used with the **Terraform Plan** step to apply a plan. 

    For steps on using the Terraform Plan step, see [Plan Terraform Provisioning with the Terraform Plan Step](https://ngdocs.harness.io/article/52n3j0ci72).
tfConfigurationFile: |-
    The **Configuration File Repository** is where the Terraform script and files you want to use are located.

    Here, you'll add a connection to the Terraform script repo. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
configForm_spec.configuration.spec.configFiles.store.spec.connectorRef: Select or create a Connector for your Git repo. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
configForm_spec.configuration.spec.configFiles.store.spec.gitFetchType: |-
    Select **Latest from Branch** or **Specific Commit ID**. When you run the Pipeline, Harness will fetch the script from the repo.

    If you think the script might change often, you might want to use a **Specific Commit ID**.

    For example, if you are going to be fetching the script multiple times in your Pipeline, Harness will fetch the script each time. If you select **Latest from Branch** and the branch changes between fetches, different scripts are run.
configForm_spec.configuration.spec.configFiles.store.spec.commitId: Enter the Commit Id to use.
configForm_spec.configuration.spec.configFiles.store.spec.branch: Enter the name of the branch to use.
configForm_spec.configuration.spec.configFiles.store.spec.folderPath: Enter the path from the root of the repo to the folder containing the script. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
TerraformPlan_stepName: |-
    The **Terraform Plan** step runs a Terraform script as a Terraform plan.

    You can then add a **Terraform Apply** step later in your stage to apply the plan. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
terraformPlanEditView-tfPlan-EXECUTION_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.secretManagerRef: |-
    A Terraform plan is a sensitive file that could be misused to alter resources if someone has access to it. Harness avoids this issue by never passing the Terraform plan file as plain text.

    Select a [Secrets Manager](https://ngdocs.harness.io/article/hngrlb7rd6) to use for encrypting/decrypting and saving the Terraform plan file. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
HarnessApproval_stepName: The Manual Approval step lets you specify Harness User Group(s) to approve or reject a Pipeline at any point in its execution. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
harnessApproval_spec.approvalMessage: Add the message for the Users in **Approvers**.
Barrier_stepName: |-
    Barriers allow you to synchronize different stages in your Pipeline, and control the flow of your deployment systematically.

    Before you add a **Barrier** step to a stage, barriers must be are added in the Pipeline's **Flow Control** settings. [Learn More](https://ngdocs.harness.io/article/dmlf8w2aeh)
barrierStep_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
JiraCreate_stepName: |-
    You can use this step to create a Jira issue as part of the execution of a Pipeline. [Learn More](https://ngdocs.harness.io/article/yu40zr6cvm)

    Jira issues are often used as part of a Jira Approval stage. [Learn More](https://ngdocs.harness.io/article/2lhfk506r8)

    [Video walkthrough](https://youtu.be/xVeICozz4lU)
jiraCreate_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
jiraCreate_spec.connectorRef: Create or select the [Jira Connector](https://ngdocs.harness.io/article/e6s32ec7i7) to use.
jiraCreate_spec.description: Add a description for the issue.
jiraCreateAddFields: |-
    Add specific fields within a Jira issue.

    Harness supports only Jira fields of type `Option`, `Array`, `Any`, `Number`, `Date`, and `String`. 

    Harness does not integrate with Jira fields that manage users, issue links, or attachments. This means that Jira fields like Assignee and Sprint are not accessible in Harness' Jira integration.
jiraSelectFromFieldList: Select from the fields Harness retrieved from Jira using the Jira Connector, Project, and Issue Type.
jiraProvideFromFieldList: Add fields for the issue.
JiraUpdate_stepName: You can update a Jira issue as a step in the execution of a Pipeline. [Learn More](https://ngdocs.harness.io/article/urdkli9e74)
jiraUpdate_name: Enter a name for this step.
jiraUpdate_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
jiraUpdate_spec.connectorRef: Create or select the [Jira Connector](https://ngdocs.harness.io/article/e6s32ec7i7) to use.
jiraUpdate_spec.issueKey: Enter the Jira issue key of the issue you want to update.
jiraUpdate_spec.transitionTo.status: Enter the status type (Issue Action) to update the issue with (In Progress, Done, etc). Harness will automatically update the issue with this status.
jiraUpdate_spec.transitionTo.transitionName: Enter the name of the transition to move the issues into.
terraformPlanEditView-tfPlan-INFRASTRUCTURE_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.secretManagerRef: |-
    A Terraform plan is a sensitive file that could be misused to alter resources if someone has access to it. Harness avoids this issue by never passing the Terraform plan file as plain text.

    Select a [Secrets Manager](https://ngdocs.harness.io/article/hngrlb7rd6) to use for encrypting/decrypting and saving the Terraform plan file.
terraformEdit-TerraformApply-INFRASTRUCTURE_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
terraformEdit-TerraformDestroy-INFRASTRUCTURE_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
TerraformPlan_stepName_ProvisionerStepConfig: |-
    When used in a stage's **Dynamic Provisioning** settings, the **Terraform Plan** step is where you connect Harness to your script repo and add your Terraform scripts. You can also define options like Workspace, etc. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    Later, you will use the **Terraform Apply** step to apply the plan and provision the target infrastructure for the deployment.
TerraformApply_stepName_ProvisionerStepConfig: When used in **Dynamic Provisioning**, the **Terraform Apply** step simply inherits its configuration from the **Terraform Plan** step you already configured. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.workspace: |-
    Harness supports Terraform [workspaces](https://www.terraform.io/docs/state/workspaces.html). A Terraform workspace is a logical representation of one your infrastructures, such as Dev, QA, Stage, Production.

    In the Workspace setting, you can simply enter the name of the workspace to use. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.backendConfig.spec.content: |-
    The **Backend Configuration** section contains the [remote state](https://www.terraform.io/docs/language/state/remote.html) values. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    Enter values for each backend config (remote state variable).

    For example, if your config.tf file has the following backend:

    ```
    terraform {
      backend "gcs" {
        bucket  = "tf-state-prod"
        prefix  = "terraform/state"
      }
    }
    ```

    In **Backend Configuration**, you provide the required configuration variables for that backend type. See **Configuration variables** in Terraform's [gcs Standard Backend](https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables) doc.

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for credentials.
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.targets: |-
    You can use the **Targets** setting to target one or more specific modules in your Terraform script, just like using the `terraform plan -target` command. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    You simply identify the module using the standard format `module.name`, like you would using `terraform plan -target="module.s3_bucket"`.

    If you have multiple modules in your script and you don't select one in Targets, all modules are used.

    See [Resource Targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting) from Terraform.
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.environmentVariables: |-
    If your Terraform script uses environment variables, you can provide values for those variables here.

    For example:

    ```
    TF_LOG_PATH=./terraform.log
    TF_VAR_alist='[1,2,3]'
    ```

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for values.
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.configuration.spec.workspace: |-
    Harness supports Terraform [workspaces](https://www.terraform.io/docs/state/workspaces.html). A Terraform workspace is a logical representation of one your infrastructures, such as Dev, QA, Stage, Production.

    In the **Workspace** setting, you can simply enter the name of the workspace to use. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformApply-INFRASTRUCTURE_: |-
    The **Terraform Var Files** section is for entering and/or linking to Terraform script Input variables.

    You can use inline or remote var files.

    Harness supports all [Terraform input types and values](https://www.terraform.io/docs/language/expressions/types.html).
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.configuration.spec.backendConfig.spec.content: |-
    The **Backend Configuration** section contains the [remote state](https://www.terraform.io/docs/language/state/remote.html) values. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    Enter values for each backend config (remote state variable).

    For example, if your config.tf file has the following backend:

    ```
    terraform {
      backend "gcs" {
        bucket  = "tf-state-prod"
        prefix  = "terraform/state"
      }
    }
    ```

    In **Backend Configuration**, you provide the required configuration variables for that backend type. See **Configuration variables** in Terraform's [gcs Standard Backend](https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables) doc.

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for credentials.
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.configuration.spec.targets: |-
    You can use the **Targets** setting to target one or more specific modules in your Terraform script, just like using the `terraform plan -target` command. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    You simply identify the module using the standard format `module.name`, like you would using `terraform plan -target="module.s3_bucket"`.

    If you have multiple modules in your script and you don't select one in Targets, all modules are used.

    See [Resource Targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting) from Terraform.
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.configuration.spec.environmentVariables: |-
    If your Terraform script uses environment variables, you can provide values for those variables here.

    For example:

    ```
    TF_LOG_PATH=./terraform.log
    TF_VAR_alist='[1,2,3]'
    ```

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for values.
TerraformDestroy_stepName_ProvisionerStepConfig: When provisioning target infrastructure, the **Terraform Delete** step deletes the infrastructure provisioned by the **Terraform Apply** step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.configuration.spec.workspace: |-
    Harness supports Terraform [workspaces](https://www.terraform.io/docs/state/workspaces.html). A Terraform workspace is a logical representation of one your infrastructures, such as Dev, QA, Stage, Production.

    In the **Workspace** setting, you can simply enter the name of the workspace to use. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.configuration.spec.backendConfig.spec.content: |-
    The **Backend Configuration** section contains the [remote state](https://www.terraform.io/docs/language/state/remote.html) values. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    Enter values for each backend config (remote state variable).

    For example, if your config.tf file has the following backend:

    ```
    terraform {
      backend "gcs" {
        bucket  = "tf-state-prod"
        prefix  = "terraform/state"
      }
    }
    ```

    In **Backend Configuration**, you provide the required configuration variables for that backend type. See **Configuration variables** in Terraform's [gcs Standard Backend](https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables) doc.

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for credentials.
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.configuration.spec.targets: |-
    You can use the **Targets** setting to target one or more specific modules in your Terraform script, just like using the `terraform plan -target` command. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    You simply identify the module using the standard format `module.name`, like you would using `terraform plan -target="module.s3_bucket"`.

    If you have multiple modules in your script and you don't select one in Targets, all modules are used.

    See [Resource Targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting) from Terraform.
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.configuration.spec.environmentVariables: |-
    If your Terraform script uses environment variables, you can provide values for those variables here.

    For example:

    ```
    TF_LOG_PATH=./terraform.log
    TF_VAR_alist='[1,2,3]'
    ```

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for values.
TerraformRollback_stepName_ProvisionerStepConfig: The **Terraform Rollback** step rolls back your provisioned infrastructure and resources and returns your environment to its pre-deployment state. [Learn More](https://ngdocs.harness.io/article/jgi6d73noy)
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.workspace: |-
    Harness supports Terraform [workspaces](https://www.terraform.io/docs/state/workspaces.html). A Terraform workspace is a logical representation of one your infrastructures, such as Dev, QA, Stage, Production.

    In the **Workspace** setting, you can simply enter the name of the workspace to use. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
TerraformPlan_stepName_StepConfig: |-
    The **Terraform Plan** step runs a Terraform script as a Terraform plan. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)

    You can run the **Terraform Plan** step to provision any resource. 

    The [Terraform Apply](https://ngdocs.harness.io/article/hdclyshiho) and [Terraform Destroy](https://ngdocs.harness.io/article/j75xc704c8) steps can inherit the plan and perform their apply and destroy operations.
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.backendConfig.spec.content: |-
    The **Backend Configuration** section contains the [remote state](https://www.terraform.io/docs/language/state/remote.html) values. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)

    Enter values for each backend config (remote state variable).

    For example, if your config.tf file has the following backend:

    ```
    terraform {
      backend "gcs" {
        bucket  = "tf-state-prod"
        prefix  = "terraform/state"
      }
    }
    ```

    In **Backend Configuration**, you provide the required configuration variables for that backend type. See **Configuration variables** in Terraform's [gcs Standard Backend](https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables) doc.

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for credentials.
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.targets: |-
    You can use the **Targets** setting to target one or more specific modules in your Terraform script, just like using the `terraform plan -target` command. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)

    You simply identify the module using the standard format `module.name`, like you would using `terraform plan -target="module.s3_bucket"`.

    If you have multiple modules in your script and you don't select one in Targets, all modules are used.

    See [Resource Targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting) from Terraform.
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.environmentVariables: |-
    If your Terraform script uses environment variables, you can provide values for those variables here.

    For example:

    ```
    TF_LOG_PATH=./terraform.log
    TF_VAR_alist='[1,2,3]'
    ```

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for values.
TerraformApply_stepName_StepConfig: |-
    The **Terraform Apply** step can apply a Terraform script and provision any infrastructure. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)

    Typically the **Terraform Apply** step is used with the **Terraform Plan** step to apply a plan. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72).
terraformEdit-TerraformApply-EXECUTION_spec.configuration.spec.workspace: |-
    Harness supports Terraform [workspaces](https://www.terraform.io/docs/state/workspaces.html). A Terraform workspace is a logical representation of one your infrastructures, such as Dev, QA, Stage, Production.

    In the **Workspace** setting, you can simply enter the name of the workspace to use. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
terraformEdit-TerraformApply-EXECUTION_spec.configuration.spec.backendConfig.spec.content: |-
    The **Backend Configuration** section contains the [remote state](https://www.terraform.io/docs/language/state/remote.html) values. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)

    Enter values for each backend config (remote state variable).

    For example, if your config.tf file has the following backend:

    ```
    terraform {
      backend "gcs" {
        bucket  = "tf-state-prod"
        prefix  = "terraform/state"
      }
    }
    ```

    In **Backend Configuration**, you provide the required configuration variables for that backend type. See **Configuration variables** in Terraform's [gcs Standard Backend](https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables) doc.

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for credentials.
terraformEdit-TerraformApply-EXECUTION_spec.configuration.spec.targets: |-
    You can use the **Targets** setting to target one or more specific modules in your Terraform script, just like using the `terraform plan -target` command. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)

    You simply identify the module using the standard format `module.name`, like you would using `terraform plan -target="module.s3_bucket"`.

    If you have multiple modules in your script and you don't select one in Targets, all modules are used.

    See [Resource Targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting) from Terraform.
terraformEdit-TerraformApply-EXECUTION_spec.configuration.spec.environmentVariables: |-
    If your Terraform script uses environment variables, you can provide values for those variables here.

    For example:

    ```
    TF_LOG_PATH=./terraform.log
    TF_VAR_alist='[1,2,3]'
    ```

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for values.
TerraformRollback_stepName_StepConfig: The **Terraform Rollback** step rolls back your provisioned infrastructure and resources and returns your environment to its pre-deployment state. [Learn More](https://ngdocs.harness.io/article/jgi6d73noy)
TerraformDestroy_stepName_StepConfig: The **Terraform Destroy** step removes any provisioned infrastructure, just like running the `terraform destroy` command. See [destroy](https://www.terraform.io/docs/commands/destroy.html) from Terraform. [Learn More](https://ngdocs.harness.io/article/j75xc704c8)
terraformEdit-TerraformDestroy-EXECUTION_spec.configuration.spec.workspace: |-
    Harness supports Terraform [workspaces](https://www.terraform.io/docs/state/workspaces.html). A Terraform workspace is a logical representation of one your infrastructures, such as Dev, QA, Stage, Production.

    In the **Workspace** setting, you can simply enter the name of the workspace to use. See the same Workspace setting in [Terraform Plan](https://ngdocs.harness.io/article/52n3j0ci72) for details.
terraformEdit-TerraformDestroy-EXECUTION_spec.configuration.spec.backendConfig.spec.content: |-
    The **Backend Configuration** section contains the [remote state](https://www.terraform.io/docs/language/state/remote.html) values. See the same **Backend Configuration** setting in [Terraform Plan](https://ngdocs.harness.io/article/52n3j0ci72) for details.

    Enter values for each backend config (remote state variable).

    For example, if your config.tf file has the following backend:

    ```
    terraform {
      backend "gcs" {
        bucket  = "tf-state-prod"
        prefix  = "terraform/state"
      }
    }
    ```

    In **Backend Configuration**, you provide the required configuration variables for that backend type. See **Configuration variables** in Terraform's [gcs Standard Backend](https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables) doc.

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for credentials.
terraformEdit-TerraformDestroy-EXECUTION_spec.configuration.spec.targets: |-
    You can use the **Targets** setting to target one or more specific modules in your Terraform script, just like using the `terraform plan -target` command. See the same **Targets** setting in [Terraform Plan](https://ngdocs.harness.io/article/52n3j0ci72) for details.

    You simply identify the module using the standard format `module.name`, like you would using `terraform plan -target="module.s3_bucket"`.

    If you have multiple modules in your script and you don't select one in Targets, all modules are used.

    See [Resource Targeting](https://www.terraform.io/docs/commands/plan.html#resource-targeting) from Terraform.
terraformEdit-TerraformDestroy-EXECUTION_spec.configuration.spec.environmentVariables: |-
    If your Terraform script uses environment variables, you can provide values for those variables here.

    For example:

    ```
    TF_LOG_PATH=./terraform.log
    TF_VAR_alist='[1,2,3]'
    ```

    You can use [Harness secrets](https://ngdocs.harness.io/article/osfw70e59c) for values.
inlineVarFileForm_varFile.identifier: |-
    You can add inline variables just like you would in a tfvar file. See the same **Targets** setting in [Terraform Plan](https://ngdocs.harness.io/article/52n3j0ci72) for details.

    In **Identifier**, enter an identifier so you can refer to variables using expressions if needed.
inlineVarFileForm_varFile.spec.content: |-
    Provide the input variables and values for your Terraform script. Harness follows the same format as Terraform.

    For example, if your Terraform script has the following:

    ```
    variable "region" {
      type = string
    }
    ```

    You could enter:

    ```
    region = "asia-east1-a"
    ```
approverInputs: You can enter variables and when the approver views the step, they can provide new values for the variables. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
K8sApply_stepName_StepConfig: |-
    By default, the Harness Kubernetes Rolling, Canary, and Blue Green steps will deploy all of the resources you have set up in the Service Definition **Manifests** section.

    In some cases, you might have resources in **Manifests** that you do not want to deploy as part of the main deployment, but want to apply as another step in the stage.

    CD stages include an **K8s Apply** step that allows you to deploy any resource you have set up in the **Manifests** section. [Learn More](https://ngdocs.harness.io/article/00el61pzok)
K8sRollingDeploy_stepName_StepConfig: |-
    The **K8s Rollout** step preforms a rolling update strategy. 

    It updates Kubernetes deployments with zero downtime by incrementally updating pod instances with new ones. New pods are scheduled on nodes using the available resources. [Learn More](https://ngdocs.harness.io/article/xsla71qg8t)
K8sCanaryDeploy_stepName_StepConfig: The **K8s Canary Deploy** step defines how many pods are deployed for a Canary test of the configuration files in your Service Definition **Manifests** section. [Learn More](https://ngdocs.harness.io/article/i5p4feil89)
K8sScale_stepName_StepConfig: |-
    When you deploy a Kubernetes workload using Harness, the number of pods you want is set in your manifests and in the deployment steps.

    With the **Scale** step, you can scale this number of running pods up or down by count or percentage. [Learn More](https://ngdocs.harness.io/article/jxe5z9domw)
K8sRollingRollback_stepName_StepConfig: If a Harness Kubernetes deployment fails, Harness will rollback to the last successful version of your workload. [Learn More](https://ngdocs.harness.io/article/rt449t1xhy)
K8sCanaryDelete_stepName_StepConfig: The **Canary Delete** step is used to clean up the workload deployed by the Canary Deployment step. [Learn More](https://ngdocs.harness.io/article/922mtcvank)
K8sDelete_stepName_StepConfig: You can remove any deployed Kubernetes resources with the **K8s Delete** step. [Learn More](https://ngdocs.harness.io/article/eaj0xuegln)
K8sBlueGreenDeploy_stepName_StepConfig: |
    The **Stage** step is added automatically when you apply the Blue Green strategy. [Learn More](https://ngdocs.harness.io/article/mog5tnk5pi)

    The **Stage** step creates the Kubernetes services and pod sets needed for your new app versions, and the deploys your new app version to the pod set receiving stage traffic.
K8sBGSwapServices_stepName_StepConfig: In **Swap** step swaps the primary service to the pod set running the new app and the stage service to the pod set running the previous app version. [Learn More](https://ngdocs.harness.io/article/mog5tnk5pi)
ShellScript_stepName_StepConfig: |
    You can run shell scripts in a CD stage using the Shell Script step. [Learn More](https://ngdocs.harness.io/article/k5lu0u6i1i)

    With the **Shell Script** step, you can execute scripts in the shell session of the stage in the following ways:

    - Execute scripts on the host running a Harness Delegate. You can use the **Delegate Selectors**  setting in **Advanced** to identify which Harness Delegate to use.
    - Execute scripts on a remote target host in the deployment Infrastructure Definition.
Barrier_stepName_StepConfig: Barriers allow you to synchronize different stages in your Pipeline, and control the flow of your deployment systematically. [Learn More](https://ngdocs.harness.io/article/dmlf8w2aeh)
"flowControl_barriers[0].name": |-
    Barriers allow you to synchronize different stages in your Pipeline, and control the flow of your deployment systematically. [Learn More](https://ngdocs.harness.io/article/dmlf8w2aeh)

    Once you add a Barrier here in **Flow Control**, you reference it in the **Barrier** steps you add to the stages of your Pipeline.
Verify_stepName_StepConfig: |-
    The **Verify** step in a CD stage uses Harness Continuous Verification (CV) to verify your deployments.

    Harness CV integrates with your APMs and logging tools to:

    - Verify that the deployed service is running safely and perform automatic rollbacks.
    - Apply machine learning to every deployment to identify and flag anomalies in future deployments.

    [Learn More](https://ngdocs.harness.io/article/3xhqq9xllp)
cvData_name: Enter a name for this step.
cvData_timeout: |-
    Enter a timeout for this step. 

    You can use:

    - `w`  for weeks
    - `d`  for days
    - `h`  for hours
    - `m`  for minutes
    - `s`  for seconds
    - `ms`  for milliseconds

    The maximum is `53w`.

    Timeouts can be set at the Pipeline level also.
cvData_spec.type: |-
    Select a type that matches your deployment strategy.

    **Rolling**, **Canary**, and **Blue Green** refer to the strategy of the stage.

    For example, Canary deployment strategies use the **Canary** Continuous Verification type, and so on.

    Typically, **Load Test** is used in lower environments like QA where there is no continuous load and the deployments are usually verified by generating load via scripts, etc.

    [Learn More](https://ngdocs.harness.io/article/3xhqq9xllp)
cvData_spec.monitoredServiceRef: |-
    Click **Click to autocreate a monitored service**.

    Harness automatically creates a Monitored Service using a concatenation of the Service and Environment names. 

    For example, a Service named `todolist` and an Environment named `dev` will result in a Monitored Service named `todolist_dev`.

    If the stage Service or Environment settings are [Runtime Inputs](https://ngdocs.harness.io/article/f6yobn7iq0), the Monitored Service and Health Sources settings will show up in the Runtime Input settings when you run the Pipeline.

    [Learn More](https://ngdocs.harness.io/article/3xhqq9xllp)
cvData_spec.spec.sensitivity: |-
    Select the risk level that will be used as failure criteria during the deployment. 

    When the criteria are met, the **Failure Strategy** for the stage or step is executed.

    For time-series analysis (APM), the risk level is determined using standard deviations, as follows: `5𝞼` (sigma) represents high risk, `4𝞼` represents medium risk, and `3𝞼` or below represents low risk.

    Harness also takes into account the number of points that deviated: 50%+ is **High**, 25%-50% is **Medium**, and 25% or below is **Low**.

    [Learn More](https://ngdocs.harness.io/article/3xhqq9xllp)
cvData_spec.spec.duration: |-
    Select the number of data points Harness uses. If you enter **10 min**, Harness will take the first 10 minutes worth of the log/APM data points and analyze it. [Learn More](https://ngdocs.harness.io/article/3xhqq9xllp)

    The length of time it takes Harness to analyze the 10 min of data points depends on the number of instances being analyzed and the monitoring tool. If you have a 1000 instances, it can take some time to analyze the first 10 minutes of all of their logs/APM data points.

    The recommended **Duration** is 10 minutes for logging providers and 15 minutes for APM and infrastructure providers.

    Harness waits 2-3 minutes to allow enough time for the data to be sent to the verification provider before it analyzes the data. This wait time is a standard with monitoring tools. So, if you set the Duration to 10 minutes, the 10 minutes excludes the initial 2-3 minute wait, but the total sample time is 13 minutes.
cvData_spec.spec.trafficsplit: ""
cvData_spec.spec.deploymentTag: |-
    Use a [Harness expression](https://newdocs.helpdocs.io/article/lml71vhsim) to reference the artifact in the stage Service settings.

    The expression `<+serviceConfig.artifacts.primary.tag>` references the primary artifact. [Learn More](https://ngdocs.harness.io/article/3xhqq9xllp)
awsAuthentication: Provide the credentials Harness will use to connect to AWS. [Learn More](https://ngdocs.harness.io/article/m5vkql35ca)
stepAwsAuthForm_accessKey: |-
    Enter the Access Key. You can either the key in plaintext or use an Encrypted [Harness Secret](https://ngdocs.harness.io/article/osfw70e59c).

    See [Access Keys and Secret Keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys) from AWS.
stepAwsAuthForm_secretKeyRef: |-
    Enter the Secret Key. You can either create a new Encrypted [Harness Secret](https://ngdocs.harness.io/article/osfw70e59c) or select an existing one.

    See [Access Keys and Secret Keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys) from AWS.
Connectviaanyavailabledelegate: If you do not select specific Delegates, Harness uses any available Delegate to perform this Connector's tasks. [Learn More](https://ngdocs.harness.io/article/2k7lnc7lvl)
Connectonlyviadelegateswhichhasallofthefollowingtags: If you select specific Delegates to perform this Connector's tasks, Harness uses those Delegate only. If these Delegates cannot perform the task, Harness does **not** use another Delegate. [Learn More](https://ngdocs.harness.io/article/2k7lnc7lvl)
gcpAuthenticationDetails: |-
    Choose the method for Harness to use when connecting to GCP. [Learn More](https://ngdocs.harness.io/article/yykfduond6)

    Select one of the following:

    - **Specify credentials here**: Enter the **Service Account Key** below.
    - **Use the credentials of a specific Harness Delegate**: Select this option to have the Connector inherit the credentials used by the Harness Delegate running in GCP.

    **Note:** For connections to a Kubernetes cluster, use Harness' platform-agnostic Kubernetes Cluster Connector.
gcpConnectorSecretKeyTooltip: |-
    Select or create a new [Harness Encrypted Text secret](https://docs.harness.io/article/ygyvp998mu) that contains the Google Cloud's Account Service Key File. [Learn More](https://ngdocs.harness.io/article/yykfduond6)

    To obtain the Google Cloud's Account Service Key File, see [Creating and managing service account keys](https://cloud.google.com/iam/docs/creating-managing-service-account-keys) from Google.

    Use JSON formatting. P12 service account keys are not recommended unless they are necessary for backwards compatibility.

    Here's an [Account Service Key download example](https://files.helpdocs.io/kw8ldg1itf/articles/6x52zvqsta/1593629254966/image.png).
K8sConnectorDetails: |+
    Choose the method for Harness to use when connecting to the cluster. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)

    Select one of the following:

    - **Specify master URL and credentials**: Enter the **Service Account Key** below.
    - **Use the credentials of a specific Harness Delegate**: Select this option to have the Connector inherit the credentials used by the Harness Delegate running in the cluster.

K8sAuthenticationTooltip: |-
    If you want to enter specific credentials manually, there are several options. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)

    **Note**: Typically, username and password is not used. The cluster would need Basic authentication enabled and a specific username and password configured for authentication.
k8ClusterForm_username: You can use an inline username or a [Harness Encrypted Text secret](https://docs.harness.io/article/ygyvp998mu). [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_password: Select or create a new [Harness Encrypted Text secret](https://docs.harness.io/article/ygyvp998mu). [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_serviceAccountToken: |-
    Add the service account token for the service account. The token should have the cluster-admin role. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)

    The token must be pasted in decoded in the [Harness Encrypted Text secret](https://docs.harness.io/article/ygyvp998mu) you create/select.
k8ClusterForm_oidcIssuerUrl: The issuer URI for the provider authentication server. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_oidcUsername: Username for a user assigned to the provider app. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_oidcPassword: Password for a user assigned to the provider app. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_oidcCleintId: Public identifier for the client that is required for all OAuth flows. In Okta, this is located in the **Client Credentials** for the app. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_oidcCleintSecret: The client secret for the app. In Okta, this is located in the **Client Credentials** for the app. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_oidcScopes: OIDC scopes are used by an application during authentication to authorize access to a user's details, like name and picture. In Okta, you can find them in the **Authorization Server Scopes** tab. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_clientKey: Create or select a Harness secret to add the client key for the client certificate. The key can be pasted into the secret either Base64 encoded or decoded. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_clientKeyCertificate: |-
    Create or select a Harness secret to add the client certificate for the cluster.

    The public client certificate is generated along with the private client key used to authenticate. The certificate can be pasted in either Base64 encoded or decoded. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_clientKeyPassphrase: Create or select a Harness secret to add the client key passphrase. The passphrase can be pasted in either Base64 encoded or decoded. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_clientKeyAlgo: Specify the encryption algorithm used when the certificate was created. Typically, RSA. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_clientKeyCACertificate: Create or select a Harness secret to add the Certificate authority root certificate used to validate client certificates presented to the API server. For more information, see [Authenticating](https://kubernetes.io/docs/reference/access-authn-authz/authentication/) from Kubernetes. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
artifactRepositoryAuthentication: |-
    Make sure the following permissions are granted to the user:

    - **Privileged User** is required to access the API, whether Anonymous or a using a specific username (username and passwords are not mandatory).
    - **Read** permission to all Repositories.

    If used as a Docker Repo, user needs:

    - List images and tags
    - Pull images

    See [Managing Permissions: JFrog Artifactory User Guide](https://www.jfrog.com/confluence/display/RTF/Managing+Permissions).
artifactRepositoryDetails: Harness supports both cloud and on-prem versions of Artifactory. [Learn More](https://ngdocs.harness.io/article/euueiiai4m)
stepArtifactoryAuthForm_username: Username for the Artifactory account user.
stepArtifactoryAuthForm_password: Select or create a new Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c`).
dockerConnectorProviderType: Select the Docker registry platform that you want to connect with Harness. [Learn More](https://ngdocs.harness.io/article/u9bsd77g5a)
dockerConnectorAuthentication: |-
    Make sure the connected user account has the following permissions:

    - Read permission for all repositories.

    The user needs access and permissions to the following:

    - List images and tags
    - Pull images

    See [Docker Permissions](https://docs.docker.com/datacenter/dtr/2.0/user-management/permission-levels/).

    **Note:** If you are using anonymous access to a Docker registry for a Kubernetes deployment, then `imagePullSecrets` should be removed from the container specification. This is standard Kubernetes behavior and not related to Harness specifically.
dockerAuthForm_username: The username for the Docker registry account.
dockerAuthForm_password: The password uses a Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c).
helmRepoAuthForm_username: If the charts are backed by HTTP basic authentication, you can also supply the username. See [Share your charts with others](https://helm.sh/docs/topics/chart_repository/#share-your-charts-with-others) from Helm.
helmRepoAuthForm_password: If the charts are backed by HTTP basic authentication, you can also supply the password. See [Share your charts with others](https://helm.sh/docs/topics/chart_repository/#share-your-charts-with-others) from Helm.
NexusConnectorDetailsTooltip: Connect Harness to your Nexus artifact repo. [Learn More](https://ngdocs.harness.io/article/faor0dc98d)
NexusConnectorAuthentication: |-
    Ensure the connected user account has the following permissions in the Nexus Server. 

    - Repo: All repositories (Read)
    - Nexus UI: Repository Browser

    In Nexus, it looks like [this](https://files.helpdocs.io/i5nl071jo5/articles/faor0dc98d/1609804056785/image.png).

    If used as a Docker Repo, the user needs:

    - List images and tags
    - Pull images

    See [Nexus Managing Security](https://help.sonatype.com/display/NXRM2/Managing+Security).
nexusAuth_username: The username for the Nexus account.
nexusAuth_password: The password uses a Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c).
awsCCDetailsTooltip: Connect Harness to AWS CodeCommit to fetch code or sync Projects. [Learn More](https://ngdocs.harness.io/article/jed9he2i45)
awsCcAuthForm_accessKey: Enter the AWS Access for the account you want to use.
awsCcAuthForm_secretKey: Enter the AWS Secret Key using a Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c).
githubURLType: |-
    You can select **Git Account** (which is a GitHub **organization**) or **Git Repository**.

    You can add a connection to your entire Git org or just a repo in the org. Selecting a Git org enables you to use one Connector for all of your subordinate repos.

    Later when you test this connection, you will use a repo in the org.

    In either case, when you use the Connector later in Harness, you will specify which repo to use.

    [Learn More](https://ngdocs.harness.io/article/v9sigwjlgo)
githubConnectionType: |-
    You can select **HTTPS** or **SSH** for the connection. 

    You will need to provide the protocol-relevant URL in **URL**.

    If you use Two-Factor Authentication for your Git repo, you connect over HTTPS or SSH. HTTPS is required a personal access token.

    [Learn More](https://ngdocs.harness.io/article/v9sigwjlgo)
githubDetailsStepForm_url: |-
    The GitHub URL is the URL for a Git org or repo. Ensure that it matches the **Connection Type** option you selected.

    - If you selected **Git Repository** in **URL Type**, enter the full URL for the repo, such as `https://github.com/org-name/repo-name`.

    - If you selected **Git Account** in **URL Type**, enter the URL without the repo name, like `https://github.com/org-name`. When you use this Connector in a Harness setting you will be prompted to provide a repo name.

    [Learn More](https://ngdocs.harness.io/article/v9sigwjlgo)
githubDetailsStepForm_validationRepo: Enter the full URL for a repo in your org.
githubAuthentication: |-
    Enter the credentials for the org or repo you selected.

    You can use a password/token for HTTPS credentials.

    If you selected SSH as the connection protocol, you must add the SSH Key for use with the connection. 

    **Note:** Readonly GitHub repos also require username and password/token.

    [Learn More](https://ngdocs.harness.io/article/v9sigwjlgo)
stepGithubAuthForm_username: Your personal GitHub account username.
stepGithubAuthForm_password: |-
    A Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c) for the credentials of your GitHub user account.

    A Personal Access Token (PAC) is required if your GitHub authentication uses 2FA. Select **Username and Token** in **Authentication**.

    Typically, you can validate your token from the command line before using it in Harness. For example:

    `curl -i https://api.github.com -u <username>:<token>`
gitHubPersonalAccessTooltip: |-
    A Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c) for the Personal Access Token (PAC).

    A PAC is required if your GitHub authentication uses 2FA.

    Typically, you can validate your token from the command line before using it in Harness. For example:

    `curl -i https://api.github.com -u <username>:<token>`

    **Note:** If you've set up 2FA in your Git repo, then you need to generate a PAC in your repo and enter that token in the **Personal Access Token** setting. See [GitHub settings](https://github.com/settings/tokens/new) for steps on setting up the personal access token. 
stepGithubAuthForm_accessToken: |-
    A Harness [Encrypted Text secret](https://ngdocs.harness.io/article/osfw70e59c) for the Personal Access Token (PAC).

    A PAC is required if your GitHub authentication uses 2FA.

    Typically, you can validate your token from the command line before using it in Harness. For example:

    `curl -i https://api.github.com -u <username>:<token>`

    **Note:** If you've set up 2FA in your Git repo, then you need to generate a PAC in your repo and enter that token in the **Personal Access Token** setting. See [GitHub settings](https://github.com/settings/tokens/new) for steps on setting up the personal access token. 
stepGithubAuthForm_apiAccessToken: ""
githubApiAuthentication: You can use a Personal Access Token or GitHub App for authentication. [Learn More about using a GitHub App with Harness](https://ngdocs.harness.io/article/nze5evmqu1)
stepGithubAuthForm_installationId: |-
    Enter the Installation ID located in the URL of the installed GitHub App.

    See an [example](https://files.helpdocs.io/i5nl071jo5/articles/nze5evmqu1/1614213226801/image.png).
stepGithubAuthForm_applicationId: |-
    Enter the **GitHub App ID** from the GitHub App **General** tab.

    See an [example](https://files.helpdocs.io/i5nl071jo5/articles/nze5evmqu1/1614213187702/image.png).
createUpdateSecretForm_secretManagerIdentifier: Harness includes a built-in Secrets Management feature that enables you to store encrypted secrets, such as access keys, and use them in your Harness Connectors and Pipelines. [Learn More](https://ngdocs.harness.io/article/bo4qbrcggv)
createUpdateSecretForm_name: Enter a name for the encrypted text. This is the name you will use to reference the text elsewhere in your resources. [Learn More](https://ngdocs.harness.io/article/osfw70e59c)
createUpdateSecretForm_value: Enter a value for the encrypted text. [Learn More](https://ngdocs.harness.io/article/osfw70e59c)
createUpdateSecretForm_description: Enter a description for the secret. A description can be very helpful when your team uses a lot of secrets for the same resource.
createUpdateSecretForm_tags: Use tags to help you sort secrets.
ff_ffListing_heading: Feature Flags (FF) is a feature management solution that enables users to change the software's functionality without deploying new code.
